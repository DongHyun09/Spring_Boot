회원가입시 Ajax를 사용하는 2가지 이유.


1. 첫번째 이유

요청에 대한 응답을 html이 아닌, Data를 받기 위해서. 
클라이언트는 웹이라고 한다면 이는 브라우저로 요청을 한다 (서버한테).
그럼 이 서버는 거기에 대한 응답을, html에 한다.
.html로 하는 것은 아니지만, html로 응답을 한다.
응답을 하면 html은 브라우저가 이해할수있는 파일이기 때문에
브라우저가 이 파일을 열어서 읽는다.

예를 들어서, 요청(회원가입 화면)을 하면 회원가입 화면을 서버가 만들어서
보여줘라 한다면, 서버가 이를 만들어서 html로 응답을 해주면 브라우저가 이것을 읽는다.
이것이 제일 정상적인 로직이다.
우리가 요청을 할때, 회원가입 화면이 아닌, 회원가입 자체를 요청할 수 있다.
회원가입 자체를 요청하면 서버는, 회원가입을 수행한다.
회원가입 수행을 하기 위해 database에 연결을 해서 회원가입을 수행해서
거기에 대한 응답을 해줄때 요청한것은 회원가입이지, 페이지를 달라는 것이 아니다.

브라우저는 클라이언트가 사용하게 되는데, 클라이언트는 회원가입을 요청을 하고나서
반드시 페이지로 이동을 하게 된다.
근데 만약에, 회원가입을 수행 한후, 보통은 메인화면을 다시 리턴을 해주는데,
즉, 메인화면 -> 회원가입 -> 메인화면 이런 순서일 것이다.(html을 응답을 해주는것)
여기에서, 클라이언트가 꼭 브라우저이기만 하지는 않을 것이다.
예를 들어서 App을 화면 디자인을 할떄 (앱은 웹브라우저가 아님)
안드로이드라면 자바코드로 하게 된다.
근데 만약 app에서 회원가입을 서버에 요청하면 
서버가 똑같이 db한테 회원가입 수행을 한다.
1. App (회원가입 요청)-> 서버 (회원가입 수행) -> db (정상) -> 서버 (HTML????)-> 앱 

이것은 말도 안되는 일.
정확히 리턴해주려면 html이 아니라 자바 코드를 리턴해줘야 한다.
근데 자바 코드를 리턴해줄수는 없어서 단순히 data만 리턴해주면 된다.
왜냐면 화면 디자인은 이미 app에 심어져있다. 우리가 app을 다운로드를 하면
app안에 화면에 대한 디자인이 다 심어져있다.
data만 리턴해서 정상이야 ! 라는 데이터만 리턴해주면 앱 안에서 자체적으로 띄우면 된다.

근데, 브라우저는 app이 아니라 미리 프로그램을 다운로드를 받는게 아니라
항상 요청을 해서 페이지를 받는 방식이다.
앱이 요청했을때와 클라이언트가 브라우저일떄 요청했을 때는 응답이 다르다.
html을 리턴받으면 되는 방식과 data를 리턴받는 방식으로써 다르다.

그러면 서버를 2번 만들어야 한다.
즉 html리턴과 data 리턴 .
근데 이렇게 2번 만들바에는 
그냥 "data를 리턴"하는 서버로 사용하면 된다.

이것을 Ajax로 요청을 하면 어떻게 되냐 ?

기본적인 로직에서 웹에서 브라우저가 회원가입 요청을 하면 
서버가 db한테 수행을 하고, 응답을 받으면 정상적으로 되었다고
브라우저에 data를 리턴을 해준다.
그럼 여기서 어떻게 하느냐 ?
다시 브라우저는 서버에 request를 해서 메인페이지를 보여준다.
이때는 메인페이지를 돌려줘야하기때문에 .html을 돌려줘야 한다.

그럼 app일 때는 ?

data를 리턴해주는 방식까지는 모두 똑같다.
app내부에서 화면을 이동하기만 하면 된다.
왜냐면 app은 화면이 이미 들고있기 때문이다.
app은 그냥 자체적으로 프로그램이 내장을 하고있기 때문에 화면을 이동한다.
브라우저는 내장을 하고있지 않기때문에 request로 화면을 보여줘야한다.

즉, data를 받기 위해서 Ajax를 사용한다.




2. 두번째 이유

비동기 통신을 하기 위해서이다.
프로그램은 일의 순서에 맞게 일을 처리한다.
예를 들어서 5가지의 일을 수행하려면 순차적으로
종료 후 실행, 종료 후 실행, 종료 후 실행하는 절차적인 로직이다.
그런데, 우리가 1번 로직, 2번 로직, 3번 로직 등등이 있을때
1번은 그냥 화면에 그림을 그리는 것이고, 2번은 단순히 연산을 하는 것이고,
3번은 도라에몽 그림을 다운로드를 하는 것, 4번은 도라에몽 그림 그리기, 5번은 화면에 그림.
3번은 외장 즉, 외부에서 다운로드를 받아야 함.

예를 들어서 화면을 구상해보자면 도라에몽을 다운로드 받는 10초 동안 모든 기능이 멈춰있다가
다운로드가 끝나면 도라에몽 그림을 그리고 , 메뉴판을 만들것이다.
이런 로직이 있다면, 10초를 기다리는 이 시간이 굉장히 비효율적이다.
그래서 어떻게 하냐면, 어차피 화면의 그림을 그리는것은 cpu, 연산도 cpu
다운로드는 저장장치가 하는 것.

1 -> 2 -> 3 -> 5 -> 4

이 순서가 되는데 3번이 다운로드가 완료되면
5번이 하던일을 끝냈거나 하던도중에 4번으로 돌아가기 위해 준비를 한다.(콜백)
근데 하던일을 하던도중에 4번을 그리고 다시 내려와서 나머지 부분을 그려내는 것을
비동기적 실행이라고 한다.
무조건 앞에 있는 것이 끝이 나야 뒤에 있는 것이 실행된다.
3번이 끝나지 않았는데 5번을 실행할수있는것은 비동기적이라고 함.


3. 

//Ajax호출시 default가 비동기 호출 
// ajax 통신을 이용해서 3개의 데이터를 json으로 변경하여 insert 요청 !!
예) $.ajax().done().fail();


->

$.ajax({
	//회원가입 수행 요청(100초 가정)
	type:"POST", 	      //insetrt 할거라
	url: "/api/user/join" //보통 join이라는 것은 잘 안적는데,
			     //왜냐면 어차피 user테이블의 데이터를 넣을거니까 user까지만 			     //적고 method가 POST면  insert라는 것을 아니가, api에 user                      			     //까지만 적자.
	data:JSON.stringify(data)
	contentType:"application/json; charset=utf-8",
	dataType:"json"
}).done(function(resp){
	alert("회원가입이 완료되었습니다.");
	alert(resp);
	location.href="/blog";
}).fail(function(){
	alert(JSON.stringify(error));
});


dataType을 굳이 선언해주지 않아도
신기하게 spring에서 알아서 변환을 해준다.





나의 프로젝트에 회원가입을 먹여보았다.
여기서 form = "POST" 방식을 사용하지 않음. 
JSON !
값 3개를 자바스크립트에서 가져가서 해보겠다.
구성을 조금 다르게 해볼것이다.

스프링이 기본적으로 찾고있는 위치가 static 폴더를 기본적으로 찾아줌
따라서 js에 정적인 자원을 놔두면 된다.


ajax 통신을 이용해서 insert 요청을 해줄 것이다.
기본적인 js파일 설정 그리고 tiles를 일단 내 방식대로 적용시켰고, 
ajax script를 가져왔다.

view 구성은 
https://www.w3schools.com/bootstrap4/bootstrap_forms.asp
참고.




LomBok 사용 (어라운드 허브 스튜디오 강의)


-->>>

lombok이라는 반복되는 메소드를 Annotation을 사용하여 자동으로 작성해주는 라이브러리
일반적으로 VO<DTO,Model,Entity 등의 데이터 클래스에서 주로 사용됨
대표적으로 많이 사용되는 Annotation으로는
@Getter
@Setter
@NoArgConstructor
@AllArgConstructor
@Data
@ToString
등이 있다.

각각 어떤 내용인지 알아보자

LomBok을 사용하려면 Lib 의존성을 사용해야 한다.

######## @Getter, @Setter
Get 필드와 Set필드를 자동으로 메소드를 만들어준다.


######## (1)@NoArgsConstructor, (2) @AllArgsConstructor, (3) @RequiredArgsConstructor

(1)은 파라미터가 없는 생성자를 생성
(2)는 모든 필드값을 파라미터로 갖는 생성자를 생성
(3)은 필드값중 final이나 @NotNull인 값을 갖는 생성자를 생성 (이것은 많이 사용되진 않음)

######## @ToString
toString 메소드를 자동으로 생성해주는 기능
@ToString 어노테이션에 exclude 속성을 사용하여 특정 필드를 toString에서 제외시킬 수 있음
ex ) 
@ToSTring(exclude = "email")
public class memeberDTO{
	private String name;
	private String email;
	private String organization;
}


######## @EqualsAndHashCode
equals,hashCode 메소드를 자동으로 생성
equlas : 두 객체의 내용이 같은지 동등성을 비교하는 연산자
hashCode : 두 객체가 같은 객체인지 동일성을 비교하는 연산자

callSuper 속성을 통해 메소드 생성시 부모 클래스의 필드까지 고려할지 여부 설정 가능
- callSuper = true -> 부모 클래스 필드 값들도 동일한지 체크

######## @Data

해당 어노테이션을; 사용하면 앞서 나온 기능들을 한번에 추가해준다.
하지만 Data라는 어노테이션은 여러가지가 다 포함되기때문에
불필요한 메소드가 추가될수있다는 점에서 조금 기피하는 경향이 있다.

여기까지가 LomBok에 대한 내용이다.
LomBok이라는 놈을 어떤 prj에서 사용할지 성향마다 갈리는 경우가 있다.
이것이 완전한 정답은 아니다. 라고 생각해야한다.




