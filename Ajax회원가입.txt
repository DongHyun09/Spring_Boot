회원가입시 Ajax를 사용하는 2가지 이유.


1. 첫번째 이유

요청에 대한 응답을 html이 아닌, Data를 받기 위해서. 
클라이언트는 웹이라고 한다면 이는 브라우저로 요청을 한다 (서버한테).
그럼 이 서버는 거기에 대한 응답을, html에 한다.
.html로 하는 것은 아니지만, html로 응답을 한다.
응답을 하면 html은 브라우저가 이해할수있는 파일이기 때문에
브라우저가 이 파일을 열어서 읽는다.

예를 들어서, 요청(회원가입 화면)을 하면 회원가입 화면을 서버가 만들어서
보여줘라 한다면, 서버가 이를 만들어서 html로 응답을 해주면 브라우저가 이것을 읽는다.
이것이 제일 정상적인 로직이다.
우리가 요청을 할때, 회원가입 화면이 아닌, 회원가입 자체를 요청할 수 있다.
회원가입 자체를 요청하면 서버는, 회원가입을 수행한다.
회원가입 수행을 하기 위해 database에 연결을 해서 회원가입을 수행해서
거기에 대한 응답을 해줄때 요청한것은 회원가입이지, 페이지를 달라는 것이 아니다.

브라우저는 클라이언트가 사용하게 되는데, 클라이언트는 회원가입을 요청을 하고나서
반드시 페이지로 이동을 하게 된다.
근데 만약에, 회원가입을 수행 한후, 보통은 메인화면을 다시 리턴을 해주는데,
즉, 메인화면 -> 회원가입 -> 메인화면 이런 순서일 것이다.(html을 응답을 해주는것)
여기에서, 클라이언트가 꼭 브라우저이기만 하지는 않을 것이다.
예를 들어서 App을 화면 디자인을 할떄 (앱은 웹브라우저가 아님)
안드로이드라면 자바코드로 하게 된다.
근데 만약 app에서 회원가입을 서버에 요청하면 
서버가 똑같이 db한테 회원가입 수행을 한다.
1. App (회원가입 요청)-> 서버 (회원가입 수행) -> db (정상) -> 서버 (HTML????)-> 앱 

이것은 말도 안되는 일.
정확히 리턴해주려면 html이 아니라 자바 코드를 리턴해줘야 한다.
근데 자바 코드를 리턴해줄수는 없어서 단순히 data만 리턴해주면 된다.
왜냐면 화면 디자인은 이미 app에 심어져있다. 우리가 app을 다운로드를 하면
app안에 화면에 대한 디자인이 다 심어져있다.
data만 리턴해서 정상이야 ! 라는 데이터만 리턴해주면 앱 안에서 자체적으로 띄우면 된다.

근데, 브라우저는 app이 아니라 미리 프로그램을 다운로드를 받는게 아니라
항상 요청을 해서 페이지를 받는 방식이다.
앱이 요청했을때와 클라이언트가 브라우저일떄 요청했을 때는 응답이 다르다.
html을 리턴받으면 되는 방식과 data를 리턴받는 방식으로써 다르다.

그러면 서버를 2번 만들어야 한다.
즉 html리턴과 data 리턴 .
근데 이렇게 2번 만들바에는 
그냥 "data를 리턴"하는 서버로 사용하면 된다.

이것을 Ajax로 요청을 하면 어떻게 되냐 ?

기본적인 로직에서 웹에서 브라우저가 회원가입 요청을 하면 
서버가 db한테 수행을 하고, 응답을 받으면 정상적으로 되었다고
브라우저에 data를 리턴을 해준다.
그럼 여기서 어떻게 하느냐 ?
다시 브라우저는 서버에 request를 해서 메인페이지를 보여준다.
이때는 메인페이지를 돌려줘야하기때문에 .html을 돌려줘야 한다.

그럼 app일 때는 ?

data를 리턴해주는 방식까지는 모두 똑같다.
app내부에서 화면을 이동하기만 하면 된다.
왜냐면 app은 화면이 이미 들고있기 때문이다.
app은 그냥 자체적으로 프로그램이 내장을 하고있기 때문에 화면을 이동한다.
브라우저는 내장을 하고있지 않기때문에 request로 화면을 보여줘야한다.

즉, data를 받기 위해서 Ajax를 사용한다.




2. 두번째 이유

비동기 통신을 하기 위해서이다.
프로그램은 일의 순서에 맞게 일을 처리한다.
예를 들어서 5가지의 일을 수행하려면 순차적으로
종료 후 실행, 종료 후 실행, 종료 후 실행하는 절차적인 로직이다.
그런데, 우리가 1번 로직, 2번 로직, 3번 로직 등등이 있을때
1번은 그냥 화면에 그림을 그리는 것이고, 2번은 단순히 연산을 하는 것이고,
3번은 도라에몽 그림을 다운로드를 하는 것, 4번은 도라에몽 그림 그리기, 5번은 화면에 그림.
3번은 외장 즉, 외부에서 다운로드를 받아야 함.

예를 들어서 화면을 구상해보자면 도라에몽을 다운로드 받는 10초 동안 모든 기능이 멈춰있다가
다운로드가 끝나면 도라에몽 그림을 그리고 , 메뉴판을 만들것이다.
이런 로직이 있다면, 10초를 기다리는 이 시간이 굉장히 비효율적이다.
그래서 어떻게 하냐면, 어차피 화면의 그림을 그리는것은 cpu, 연산도 cpu
다운로드는 저장장치가 하는 것.

1 -> 2 -> 3 -> 5 -> 4

이 순서가 되는데 3번이 다운로드가 완료되면
5번이 하던일을 끝냈거나 하던도중에 4번으로 돌아가기 위해 준비를 한다.(콜백)
근데 하던일을 하던도중에 4번을 그리고 다시 내려와서 나머지 부분을 그려내는 것을
비동기적 실행이라고 한다.
무조건 앞에 있는 것이 끝이 나야 뒤에 있는 것이 실행된다.
3번이 끝나지 않았는데 5번을 실행할수있는것은 비동기적이라고 함.


3. 

//Ajax호출시 default가 비동기 호출 
// ajax 통신을 이용해서 3개의 데이터를 json으로 변경하여 insert 요청 !!
예) $.ajax().done().fail();


->

$.ajax({
	//회원가입 수행 요청(100초 가정)
	type:"POST", 	      //insetrt 할거라
	url: "/api/user/join" //보통 join이라는 것은 잘 안적는데,
			     //왜냐면 어차피 user테이블의 데이터를 넣을거니까 user까지만 			     //적고 method가 POST면  insert라는 것을 아니가, api에 user                      			     //까지만 적자.
	data:JSON.stringify(data)
	contentType:"application/json; charset=utf-8",
	dataType:"json"
}).done(function(resp){
	alert("회원가입이 완료되었습니다.");
	alert(resp);
	location.href="/blog";
}).fail(function(){
	alert(JSON.stringify(error));
});


dataType을 굳이 선언해주지 않아도
신기하게 spring에서 알아서 변환을 해준다.

