

<2023/05/15~2023/05/16. 1~13강)

1. Spring Boot란 ? (1강)
Web App + Spring DI/Transaction/MVC/,,, + Servlet / JSP + WAS(Tomcat,...)
Spring 환경에 Boot를 얹어서 작업해라. 아주 편리해질 것이다.


2.학습개요 (2강)
데이터를 DB에 저장하는 라이브러리로는 MyBatis가 있으니 이것으로 갈 것이다.
따라하기 식의 Boot를 하겠다는 뉴렉처쌤. 하지만 괜찮다. 기본기는 어느정도 숙지하고 있으니.


3.개발환경 준비(3강)

sts를 깔았음.
Spring과 관련되지 않은 것들은 최대한 제거한 상태로 준비되어있다.
이 상태로 java 어플리케이션을 개발, Spring Prj을 개발 할 것이다.

4.Spring Boot Starter Prj 만들기 (4강)

Spring Starter Project 생성

Name : SpringWeb
Type : Maven
java version : 8
Group : com.newlecture
artifact : SpringWeb
Version : 1.0
Description : Newlecture Spring Boot Project
Package : com.newlecture.springweb

Next

가장 기본적인 라이브러리 하나만 추가 하고 가자.
web을 확장하면 Spring web을 추가 하고 가자.

finish

이 녀석은 main함수를 가지고 있다.
톰캣도 Spring Boot 밑에 들어간다는 얘기가 된다.

HomeController를 추가할 것인데
이 controller Package명을 손상해서는 안된다.
우리는 
com.newlecture.springweb.controller로 가져갈 것.

URL은 Index 매핑. "/index"

	@RequestMapping("/index")
	public String asdf() {
		return "Hello Spring Boot";
	}
	
	@RequestMapping("/aabb")
	public String aaa() {
		return "aaaa";
	}

이 놈들을 실행해보기 위해 main함수를 실행 시켜보자, 했더니 실행이 안된다.

댓:

혹여 oracle 11g 버전을 사용하고 계시는 분은 8080포트를 이미 오라클이 점유하고 있어서 서버포트 에러때문에 메인함수가 실행되지 않을 것 같습니다. 
src/main/resources패키지의 application.properties에 들어가서
server.port=8090
이 한문장만 추가하고 저장해주시면 포트번호가 8090으로 바뀝니다. 다른 번호로 하시고싶은 분은 다른 번호로 하셔도 무방할것 같습니다.


실행됨.

http://localhost:8082/aabb
aaaa

http://localhost:8082/index
Hello Spring Boot


5. 수업용 HTML파일 준비하기 (5강)

Newlecture 사이트에....

근데 webapp을 추가후 Wizzard에 html을 만들어보려고 하니 안뜸.

 댓:

Q.
질문있어요. 
1분 36초 경에 나타나는 화면(Wizards)에서 ... 
저의 화면에서는 Others라는 폴더가 없어요.  다른 폴더는 다 있는데...
어떻게 해야 Other폴더를 찾을 수 있나요?.


A.
(1) STS4에서는 현시점(2021년 11월경) WEB관련 HTML, CSS, JSP 파일등을 생성 하려면 Tools를 따로 설치해줘야 합니다.

(2) 상단 메뉴바에서 Help -> Eclipse MarketPlace... 클릭해줍니다.

(3) MarketPlace에서 Java and web 검색 후 Eclipse Enterprise Java and Web Developer Tools install을 클릭해서 다운로드 받습니다.

잘 됨.

src -> main -> webapp 에서 
aa.html <body>aa test</body>
를 써주고 HomeController를 실행한 후, 
url에 http://localhost:8082/aa.html를 써주니 아주 잘 실행된다.
얘가 홈디렉토리구나 ! 여기다가 옮길것이냐 ?
그건 아니다.
src/main/resource를 열어보면 static 이 있는데, css,img등은 이곳에다가 옮길것이다.

Spring boot는 홈 디렉토리가 두개가 있다고 보면된다

정적인 파일들의 홈디렉토리 (static) 동적인 파일들의 홈디렉토리 (webapp)이 있다고 보면 됨.
앞으로 추가는 webapp에 두고 쓸것이다.
다음 시간에는 내용들을 가져다가 쓸 것.

6. JSP View 추가하기 (6강)

JSP문서를 만들기 전에 JSP라는 파일이 인식이 될 수 있게끔 설정해줄것이다.
webapp루트에서 index.jsp를 요청하면 그 페이지의 내용을 보여줘야 하는데
다운로드가 된다(...)

이유는 jsp라는 파일을 처리할수있는 파일로 인식하지 못하기 때문이다.
이것을 막기위해서는 jsp라는 파일을 처리할수있는 jsp라는 라이브러리를 추가할 수 있도록 한다.

Boot를 시작하기 위해서 여러가지 방법이 있는데 
run as 에 들어간 후 Spring boot app을 누르는 방법도 있고 기존 ctrl + F11도 있다.
그리고 Boot Dashboard를 통해서 시작하는 방법도 있다. 

이렇게 index.jsp를 만들고 시작했더니 다운로드가 된다.

라이브러리를 추가해야한다.

# maven repository에서 dependency에 tomcat embed jasper를 추가.

그랬더니 version에 노란줄이 뜬다. 

		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
			<version>10.0.27</version>
		</dependency>	

그냥 <version> 부분을 지워버리면 자신에게 맞는 버전을 알아서 쓰게해준다.

이 상태에서 이제 서버를 키고 localhost를 요청해보면 jsp가 잘뜬다.


7.사용자 공지를 위한 MVC 구현하기 (7강)

Customer의 Notice를 위한 package와 view를 따로 만들어준다.
@RestController들은 문자열로 반환
@Controller는 View 페이지로 인식하기 위한 것.
Model을 이용.

8. Mapping, View 위치 바로잡기 (8강)

view에서 데이터없이 view단이 요청이 되버리면 안된다.
이것은 버그 아닌 버그이다.
사용자가 직접 요청해서는 안되는 것.
WEB-INF를 만든다.
View를 따로 관리하기 위해 View라고하는 폴더를 이 안에다가 만들어준다.

	@GetMapping("list")//list,detail,edit,reg,del
	public String list(Model model) {
		
		model.addAttribute("test", "Hello~");

		return "/WEB-INF/view/customer/notice/list.jsp";
	}
	
	@RequestMapping("detail")//list,detail,edit,reg,del
	public String detail() {
		return "/WEB-INF/view/customer/notice/detail.jsp";
	}
	
이렇게 위치를 잡아준다.


9. View Resolver 설정 (9강)

src/main/resource에서 application.properties에서 

spring.mvc.view.prefix=/WEB-INF/view/
spring.mvc.view.suffix=.jsp

이 녀석들을 적어준다.

그러면 return "/customer/notice/detail";
이렇게 줄이는것이 가능해진다.

간단..


10. devtools 설정하기 (10강)

부트를 다시 시작할 필요없이 dependency하나만 추가해주면 저장된 내용을 알아서
재시작하게 해준다.

#

<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <version>2.6.6</version>
</dependency>


이것도 version을 지워보자.
똑같이 노란색 줄 오류가 뜸.

11.실습: 관리자를 위한 공지사항 페이지 추가하기 (11강)

관리자를 위한 공지사항 컨트롤러, view 추가했음.

12. 관리자를 위한 공지사항 페이지 추가하기 (12강)

위와 같음. (했다.)

13. 페이지 공통분모 집중화(13강)

Spring FrameWork 강의 참조


<2023/05/15~2023/05/16. 14~20강 // ~ MySql강의 듣기 )


14. Tile 지시서(14강)
설정한 TilesViewResolver에서 먼저 찾게 됨.
여기서 합쳐져서 반환하게 됨.

15. Tiles ViewResolver 생성하기(15강)

일반적으로 사용자 요청이있으면 Controller가 반환하게 됨.
지시서에 있는 내용대로 page를 합치고 합친 것을 반환하는 것이 Tiles ViewResolver이다.


타일즈와 관련된 객체를 만든다.

@Configuration
public class TilesConfig {
     @Bean
     public TilesConfigurer tilesConfigurer(){
      TilesConfigurer tilesConfigurer = new TilesConfigurer();
      tilesConfigurer.setDefinitions(new String[] { "/WEB-INF/tiles.xml"} );
      tilesConfigurer.setCheckRefresh(true);
      return tilesConfigurer;
    }

    @Bean
    public TilesViewResolver tilesViewResolver(){
       TilesViewResolver  viewResolver = new TilesViewResolver();
       viewResolver.setViewClass(TilesView.class);
       viewResolver.setOrder(1);
       return viewResolver;
   }    
}

@Configuration 
@Bean <- IoC컨테이너에 담을 수 있게 해준다.
@Bean은 콩을 주는 함수. 



16. Tiles 패턴 사용하기 (16강)

이전 과 같음.
Tiles WildCard.


17. Admin을 위한 Layout페이지 만들기

위와 같음.

18. Tiles의 추가 기능들(18강)

첫번째로, 공통분모를 이렇게 만들어주게 된다면,
<definition name="Layout.common" template="/WEB-INF/view/inc/layout.jsp">
		<put-attribute name="title" value="GoWithNewLec" />
		<put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
		<put-attribute name="body" value="/WEB-INF/view/{1}.jsp" />
		<put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
	</definition>



두번째로, 이렇게 상속(extends)을 받아서 공통된 부분은 빼주면 된다.
<definition name="admin.*.*.*" template="/WEB-INF/view/admin/inc/layout.jsp" extends="Layout.common">


19. MyBatis 설정하는 방법
일단 MySql과 MyBatis 라이브러리 추가.
Interface를 거쳐서 ServiceImp.
SQL구문을 DAO라는 녀석을 거친다.
서비스를 구현하는 사람은 자바 객체를 구현할수있어야 한다.
MyBatis는 Dao라는 녀석을 구현할때 반복적인 부분이많은데 이 부분을 확 줄여주는게 MyBatis이다.
MyBatis는 사용률이 높고 굉장히 유연하게 사용된다.
과거에는 여러가지 설정이있었는데, 이 설정이 많이 적어졌다.거의 제로에 가까워졌다.
#라이브러리를 추가 해준다. Mapper객체를 구현할 때, 이것이 알아서 해준다.
일단 MyBatis를 쓰기 위해서는 JDBC(MySql) MyBatis 라이브러리를 가져와야 한다.

application properties에 db 계정정보만 넣어주면 된다.
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://server/db...
spring.datasource.username=사용자ID
spring.datasource.password=비밀번호

20. 공지사항을 관리하기 위한 Service와 Dao 준비하기(20강)

NoticeController에 data를 이용할수 있도록
data를 제공받게 service객체를 만듬.
list에 Notice란 녀석을 제공받고 싶다. service.getList.
service 멤버를 만들어줬음.
NoticeService 인터페이스를 구현.

	
		@Autowired
		private NoticeService service;
	
		@RequestMapping("list")
		public String list() {
			
			List<Notice> list = service.getList();
			
			return "admin.board.notice.list";
		}
		@RequestMapping("detail")
		public String detail() {
			
			Notice notice = service.get(1);
			
			return "admin.board.notice.detail";
		}

Service를 구현하기 위한 구현체가 필요하니
ServiceImp을 만듬. 

데이터를 가져오는 작업은 Dao가 하는 것이고,
ServiceImp는 여러 Dao의 기능이 종합적으로 사용될 필요가 있으면 이 녀석이 담당해주는 것이다.


	@Autowired
	private NoticeDao noticeDao;
	
	@Override
	public List<Notice> getList() {
		
		List<Notice> list = noticeDao.getList();
		
		return list;
	}
List를 얻을 건데, Dao로부터 호출한후 list를 반환.

컨트롤러는 Service, service는 dao.
MyBatis를 쓰자.


21. Mapper 객체 만들기(21강)

MyBatis를 이용하기 위해 라이브러리 추가.
dependency를 설정할 수도 있는데,
staters를 추가하는 방법은 또 있다.
pom파일 말고도,
prj를 우클릭, spring 항목에서 add starters를 클릭.

여기서 SQL이라는 항복을 클릭 하고 MyBatis Framework와 
MySQL Driver 선택. 
화살표 아이콘 클릭으로 주입해 줌.
dependency 성공적으로 추가 완료 됨.
이젠 MyBatis로 구현

Dao에서 select문을 추가해준다고 할 때,
@Select를 써줌.
@Insert 등. 


@Mapper
public interface NoticeDao {
	@Select("select * from notice")
	List<Notice> getList();

	Notice get(int id);

}
Mapping된것이 있다고 @Mapper를 달아주면
MyBatis가 IoC컨테이너에 담아줌.

이렇게 연결 해줬는데,
database 계정정보를 알아야되니 
application.properties에서 설정을 해준다.

# mysql settings
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/newlecture
spring.datasource.username=newlecture
spring.datasource.password=1111

이제 이것을 IoC컨테이너에서 꺼내서 써야 됨.

22. 스프링 객체 사용방법 (Dependency Injection 그리고 IoC 컨테이너) (22강)

B라는 객체를 만들기 위해, 다른 객체를 이용해서 만든다고 치자 (C). C라는 객체는 B를 위한 부속품. 이 부속품을
Dependency (의존성) 임. 그냥 부품이라고 이해하자.
B라는 녀석은 또 A를 이용해서 만든다고 침. (Dependency)
Interface를 통해 분리하는 과정이 가장 바람직하다.
App -> frame -> A -> B -> C

App 
Frame f = new Frame();
A a = new A();
f.setA(a)
객체를 생성하는 어노테이션이 좀 세분화 되어있다.
IoC 컨테이너 : f:Frame -> a:A -> b:B
계속 담는다 담아.


23. Mapper 객체를 이용해서 공지 목록 출력하기(23강)

위 과정으로 db연동은 끝남.
일단 Controller로 감.
Controller에서는 View페이지에 전달하기 위한
list객체를 만들었음.
service객체에서 가져왔음.


@Controller
@RequestMapping("/customer/notice/")
public class NoticeController {
	
	@Autowired ##IoC컨테이너에 인터페이스 구현하고있는 객체가 존재한다고 가정.
 	private NoticeService(인터페이스 자료형) service; ##NoticeService가 실제로 존재할수있도록 구현체로 감(NoticeServiceImp)
	
	@GetMapping("list")//list,detail,edit,reg,del
	public String list(Model model) {
		
		List<Notice> list = service.getList();
		
		model.addAttribute("list", list);

		return "customer.notice.list";
	}





구현체(NoticeServiceImp)를 IoC컨테이너에 담을것임.
@Service를 사용하는 것이 바람직함.




@Service
public class NoticeServiceImp implements NoticeService{

	@Autowired
	private NoticeDao noticeDao;
	
	@Override
	public List<Notice> getList() {
		
		List<Notice> list = noticeDao.getList();
		
		return list;
	}
여기서도 NoticeDao를 IoC에서 가져오겠다고 함.
IoC에서 NoticeDao를 구현한 구현체가 있어야 됨. 있음.

Controller는 Service를 통해서, Service는 Dao라는 Mapper 객체를 통해서 data를 가져올것이다.

MySQL WorkBench에서 관계 수정.

select * from newlecture.notice;

(1) memeber 테이블과 notice 테이블에 데이터를 넣음.
(2) Notice에 만들어줌.
기본 생성자 추가. 
속성들을 셋팅할수있게끔하는 생성자 오버로드.
getter setter.
객체가 갖고있는 값들을 쉽게 출력해볼수있게 하기위해 toString.


컨트롤러에서 service를 이용해서 dao가 제공해주고있음.
이제 list.jsp에서 넘겨받는 데이터를 forEach로 보여주자 ! 성공.


24.Notice View 만들기 (24강)

create view NoticeView
as
select n.*, m.name memeberBame from notice n 
join member m on n.memberId = m.id;


View table을 만들어준 후 join하고 
entity 패키지에 NoticeView 생성 후, Impl, Service, Controller. 그에 맞게 각 수정. 

create view NoticeView
as
select n.*, m.name memeberBame from notice n 
join member m on n.memberId = m.id;


http://localhost:8082/customer/notice/list

이런식으로 다른 부모 테이블외에 컬럼이 필요하다면 
View를 만들어서  목록을 준비하면 된다.

25.Mybatis Column 매핑 (25강)

view table의  컬럼 이름을 바꿔버리면
entity의 setter명(memberName)과 view 컬럼(member_Name)과 이름이 달라서 
호환이 되지 않는다. 
이럴 때는, 

@Mapper
public interface NoticeDao { 
	
	@Result(property="memberName", column="member_name")
	@Select("select * from noticeview")
	List<NoticeView> getList();

	Notice get(int id);

}

이런식으로 써주면 된다.
그럼 값이 정상적으로 출력이 된다.

regdate -> reg_date
memberId-> member_id로 컬럼을 바꿨는데,

이렇게 여러개를 바꿨을 때는 배열처럼 사용할수있다.
예제를 보면

	
	@Results({
		@Result(property="memberName", column="member_name"),
		@Result(property="regdate", column="reg_date")
				})

이렇게 바꿔쓸 수 있다.
http://localhost:8082/customer/notice/list



26.Mapper에 param 포함하기(26강)


	@GetMapping("list")//list,detail,edit,reg,del
	public String list(Model model) {
		
		int page = 1;
		String field = "title";
		String query = "";
		
		List<NoticeView> list = service.getList();
		
		model.addAttribute("list", list);

		return "customer.notice.list";
	}

사용자가 1페이지를 달라하고,
검색필드를 title, 쿼리값으로 모든걸 검색했다 치자.

-> 바뀐 인터페이스

public interface NoticeService {

	List<NoticeView> getList(int page, String field, String query);

	Notice get(int id);

}

->구현체 (impl)

	@Override
	public List<NoticeView> getList(int page, String field, String query) {
		
		List<NoticeView> list = noticeDao.getList();
		
		return list;
	}



MySQL ->

select * from noticeview
where title like '%3%' (3이 들어간것만)
order by regdate desc
limit 10;

삽입된 데이터를 10개까지만 보여주겠다.

limit 10 offset 1;
하나를 건너뛰고 10개를 보여주겠다.

limit 10 offset 0;
-> 처음부터 10개가 나옴

limit 10 offset 10;
-> 다음 페이지가 나오게 됨.

이것을

limit 0,10; (건너뛰지 않고 10개)
limit 10,10; (건너뛰고 10개)


자 이제 dao를 바꿔줌

@Select("select * from noticeview "
			+ "where title like '%3%' "
			+ "order by regdate desc "
			+ "limit 0, 10;")

전달할 값이 총 4개가 된다.
limit값 (0,10), title, %3%


Dao ->

@Select("select * from noticeview "
			+ "where title like '%3%' "
			+ "order by regdate desc "
			+ "limit 0, 10;")
	List<NoticeView> getList(int offset, int size, String field, String query);



NoticeServiceImpl ->

	
	@Override
	public List<NoticeView> getList(int page, String field, String query) {
		
		int size = 10;
		int offset = 0+(page-1)*size; 
//page 1이면 offset 0, 2 -> 10, 3 -> 20 an=a1+(n-1)d -> 0+(page-1)*10
		
		List<NoticeView> list = noticeDao.getList(offset, size, field, query);
		
		return list;
	}


이제 이 안에서 계산을 해줘야됨.
첫항이 0이고 공차가 10인 등차수열이다.


이제 Noticedao로 와서,
MyBatis에서는 쿼리 안에 값을 꽂을때는
#{}를 써야된다.


@Select("select * from noticeview "
			+ "where title like '%3%' "
			+ "order by regdate desc "
			+ "limit 0, 10;")

----->>>>>



	@Select("select * from noticeview "
			+ "where ${field} like '%${query}%' "
			+ "order by regdate desc "
			+ "limit #{offset}, #{size};")

#의 의미는 값을 꽂는다.
그런데 filed를 title이 들어가는게 아니고 양쪽에
'title' 이렇게 들어가버린다.
이런 문제를 해결하기 위해, 값이 아닌 title이라는 것만 남기기 위해서는 ${}를 쓰면 된다.
이것을 쓰면 그대로 문자열을 꽂아넣게 된다.
뒤에도 마찬가지.


자 이제 정리하면,
Controller에서 값이 전달될것이고, serviceimp에서 dao로 전달할때 dao에서는 구현하기 위해 값을 잘 꽂아놨음.

dao라는 녀석을 구현할 때 인자를 꽂아넣는 방법을 알아봤다.



27. xml을 이용한 매핑(27강)

지난 시간까진 @select같은 annotation을 이용해서 매핑을 했다.
쿼리문이 복잡해지면 복잡해질수록 어노테이션을 이용하는것은 복잡성을 높일수밖에없다.
그래서 이 방법은 좀 아님.

지금 우리가 구현한 interface는 MyBatis와 떼기 조금 어려워졌다.


//	@Results({
//		@Result(property="memberName", column="member_name"),
//		@Result(property="regdate", column="reg_date")
//				})
	@Select("select * from noticeview "
			+ "where ${field} like '%${query}%' "
			+ "order by regdate desc "
			+ "limit #{offset}, #{size};")


이것을 잘라내버림.

NoticeDao 패키지 안에
NoticeDaoMapper 패키지를 만들고,
NoticeDaoMapper.xml을 만들어준다.

xml에

<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.mybatis.example.BlogMapper">
  <select id="selectBlog" resultType="Blog">
    select * from Blog where id = #{id}
  </select>
</mapper>

이 녀석 (MyBatis 홈페이지 Getting Started)을 복사 붙여넣기 해준다.

<mapper namespace="com.newlecture.springweb.dao.NoticeDao">

여기에는 interface의 풀 네임을 써줘야 한다.


<mapper namespace="com.newlecture.springweb.dao.NoticeDao">
	<select id="getList">
			select * from noticeview 
			where ${field} like '%${query}%'
			order by regdate desc
			limit #{offset}, #{size}	
	</select>
</mapper>

이렇게 써줌으로서 쿼리의 복잡도도 조금 더 간단히 풀어줄수있고, Mybatis로부터 조금더 멀어질수도 있다.
이녀석을 반환할때, MyBatis는 결과집합을 담아줄때 어떠한 그릇에 entity에 담아줄까요 ?  물어보는데, 
NoticeView가 entity 그릇.

이것을 써주기 위해 ,
<mapper namespace="com.newlecture.springweb.dao.NoticeDao">

이렇게 써준다.
이게 목록인지, 단일값인지는 안써줘도 된다.

insert도 구현해보자.

return값은 정수값이다. 우리가 필요한 값은 입력값이다.
이때 notice라는 entity에 담아줄것이기 때문에 인자로 들어올 parameterType을 써주면 된다.
<insert id="insert" parameterType="com.newlecture.springweb.Notice">

이렇게 xml을 만들어준것을 찾아주기위해
application.properties에 추가해줄 것이 있다.

mybatis.mapper-locations=classpath:com/newlecture/springweb/dao/mybatis/mapper/*.xml


이 녀석안에 xml을 여러개 만들어줄것이란 걸 알려주기 위해 *을 썼음.

28.XML proposals 오류 문제(28강)

"https://mybatis.org/dtd/mybatis-3-mapper.dtd"

dtd는 사용할수있는 태그를 정의할수있는 문서를 정의하는것.


<를 누르면 태그를 보여주는데, 여기서는 안나온다.
이것을 해결해주기 위해, 이클립스 마켓플레이스에 
xml을 검색애서 ecilpse xml editors를 설치해준다.
근데 나는 설치가 되어있다.


29.NoticeService 인터페이스 정의하기(29강)

Dao를 구현하기 위해서 필요한 service가 무엇인지 ?


NoticeService
-페이지를 요청할 때
List<NoticeView> getViewList(); --> 작성자는 memeber라는 녀석을 가져와야되기 때문에 view를 가져와야 한다.
int getCount(); --> 전체 페이지

-검색을 요청할 때
List<NoticeView> getViewList(String field, String query);

-페이지를 요청할 때(버튼 누를때)
List<NoticeView> getViewList(int page, String query);
ex) 페이지를 누를때 3개의 페이지에서 페이지를 누를때
검색결과에 의한 페이지가 나와야 한다.
int getCount(String field, String query);

-일괄공개를 요청할때 (공개되어있는 녀석은 check가 되어있도록)
int updatePubAll(int[] publds, int[] closelds);

-일괄삭제를 요청할 때
int deleteAll(int[] lds);

-자세한 페이지를 요청할 때
NoticeView get(id);

이렇게 끝나는게 아닌, 
우리가 구현한 페이지를 잘보면
자세한 페이지 안에서도 다음글과 이전글이 구현되어있다.

따라서 

Notice getNext(id);
Notice getPrev(id);

이녀석들도 만들어준다.


-수정 페이지를 요청할 때
NoticeView get(id)
update(Notice notice);
int delete(int id);
int insert(Notice notice);





자 정리해보면, NoticeService에

package com.newlecture.springweb.service;

import java.util.List;

import com.newlecture.springweb.entity.Notice;
import com.newlecture.springweb.entity.NoticeView;

public interface NoticeService {

	// --페이지를 요청할 때
	List<NoticeView> getViewList();

	// --검색을 요청할 때
	List<NoticeView> getViewList(String field, String query);

	// -페이지를 요청할 때
	List<NoticeView> getList(int page, String field, String query);

	int getCount();

	int getCount(String field, String query);

	// -자세한 페이지 요청할 때
	Notice get(int id);

	Notice getNext(int id);

	Notice getPrev(int id);

	// -일괄공개를 요청할 때
	int updatePubAll(int[] pubIds, int[] closeIds);

	// -일괄삭제를 요청할 때
	int deleteAll(int[] ids);

	// -수정 페이지를 요청할 때
	int update(Notice notice);

	int delete(int id);

	int insert(Notice notice);

}

이 녀석들이 들어가게 된다.

--> NoticeView get(int id)를
NoticeView getView(int id)로 변경.


30. NoticeDao 인터페이스 정의하기(30강)

	@Override
	public List<NoticeView> getViewList() {
		// TODO Auto-generated method stub
		return getViewList(1, "title", "");
	}

	@Override
	public List<NoticeView> getViewList(String field, String query) {
		// TODO Auto-generated method stub
		return getViewList(1, field, query);
	}

	@Override
	public List<NoticeView> getViewList(int page, String field, String query) {
		
		int size = 10;
		int offset = 0+(page-1)*size; //page 1이면 offset 0, 2 -> 10, 3 -> 20 an=a1+(n-1)d -> 0+(page-1)*10
		
		List<NoticeView> list = noticeDao.getList(offset, size, field, query);
		
		return list;
	}


이렇게 같은것인데 인자가 다를 경우
맨 마지막 것만 구현하는 것이다.

마지막을 재호출하는 방법으로 가야 된다.
(인자가 제일 많은 녀석을 재호출하는 방법)

각각 함수들의 반환값을 정의해준다.NoticeDao.~~

빨간줄들을 create 해준다.

이제 이것들을 MyBatis를 이용해서, Mapper로 구현하면 된다.

